// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package dbmodel

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const addUserCoins = `-- name: AddUserCoins :exec
UPDATE user_coin
SET balance = balance + $1,
      updated_at = now()
WHERE user_id = $2
`

type AddUserCoinsParams struct {
	Balance int32     `json:"balance"`
	UserID  uuid.UUID `json:"user_id"`
}

func (q *Queries) AddUserCoins(ctx context.Context, arg AddUserCoinsParams) error {
	_, err := q.db.ExecContext(ctx, addUserCoins, arg.Balance, arg.UserID)
	return err
}

const afterProcessingUpdateNotes = `-- name: AfterProcessingUpdateNotes :one
UPDATE notes
SET
    title = $1,
    transcript = $2,
    word_count = $3,
    status = 'completed',
    updated_at = NOW()
WHERE id = $4
RETURNING
    id,
    user_id,
    audio_url,
    audio_duration_seconds,
    audio_file_size_mb,
    transcript,
    title,
    word_count,
    status,
    search_vector,
    created_at,
    updated_at
`

type AfterProcessingUpdateNotesParams struct {
	Title      sql.NullString `json:"title"`
	Transcript sql.NullString `json:"transcript"`
	WordCount  sql.NullInt32  `json:"word_count"`
	ID         uuid.UUID      `json:"id"`
}

func (q *Queries) AfterProcessingUpdateNotes(ctx context.Context, arg AfterProcessingUpdateNotesParams) (Note, error) {
	row := q.db.QueryRowContext(ctx, afterProcessingUpdateNotes,
		arg.Title,
		arg.Transcript,
		arg.WordCount,
		arg.ID,
	)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AudioUrl,
		&i.AudioDurationSeconds,
		&i.AudioFileSizeMb,
		&i.Transcript,
		&i.Title,
		&i.WordCount,
		&i.Status,
		&i.SearchVector,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCoinTransaction = `-- name: CreateCoinTransaction :exec
INSERT INTO coin_transactions (
    user_id,
    amount,
    reason
) VALUES (
    $1,
    $2,
    $3
)
`

type CreateCoinTransactionParams struct {
	UserID uuid.UUID `json:"user_id"`
	Amount int32     `json:"amount"`
	Reason string    `json:"reason"`
}

func (q *Queries) CreateCoinTransaction(ctx context.Context, arg CreateCoinTransactionParams) error {
	_, err := q.db.ExecContext(ctx, createCoinTransaction, arg.UserID, arg.Amount, arg.Reason)
	return err
}

const createNotes = `-- name: CreateNotes :one
INSERT INTO notes(user_id,audio_url,status,audio_file_size_mb,audio_duration_seconds)
VALUES($1,$2,'processing',$3,$4)
RETURNING id, user_id, audio_url, audio_duration_seconds, audio_file_size_mb, transcript, title, word_count, status, search_vector, created_at, updated_at
`

type CreateNotesParams struct {
	UserID               uuid.UUID      `json:"user_id"`
	AudioUrl             sql.NullString `json:"audio_url"`
	AudioFileSizeMb      sql.NullInt32  `json:"audio_file_size_mb"`
	AudioDurationSeconds sql.NullInt32  `json:"audio_duration_seconds"`
}

func (q *Queries) CreateNotes(ctx context.Context, arg CreateNotesParams) (Note, error) {
	row := q.db.QueryRowContext(ctx, createNotes,
		arg.UserID,
		arg.AudioUrl,
		arg.AudioFileSizeMb,
		arg.AudioDurationSeconds,
	)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AudioUrl,
		&i.AudioDurationSeconds,
		&i.AudioFileSizeMb,
		&i.Transcript,
		&i.Title,
		&i.WordCount,
		&i.Status,
		&i.SearchVector,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserCoins = `-- name: CreateUserCoins :exec
INSERT INTO user_coin (user_id, balance)
VALUES ($1, $2)
`

type CreateUserCoinsParams struct {
	UserID  uuid.UUID `json:"user_id"`
	Balance int32     `json:"balance"`
}

func (q *Queries) CreateUserCoins(ctx context.Context, arg CreateUserCoinsParams) error {
	_, err := q.db.ExecContext(ctx, createUserCoins, arg.UserID, arg.Balance)
	return err
}

const deductUserCoins = `-- name: DeductUserCoins :exec
UPDATE user_coin
SET balance = balance - $1,
    updated_at = now()
WHERE user_id = $2
  AND balance >= $1
`

type DeductUserCoinsParams struct {
	Balance int32     `json:"balance"`
	UserID  uuid.UUID `json:"user_id"`
}

func (q *Queries) DeductUserCoins(ctx context.Context, arg DeductUserCoinsParams) error {
	_, err := q.db.ExecContext(ctx, deductUserCoins, arg.Balance, arg.UserID)
	return err
}

const deleteNoteById = `-- name: DeleteNoteById :exec
DELETE FROM notes
WHERE id = $1
    AND user_id = $2
`

type DeleteNoteByIdParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteNoteById(ctx context.Context, arg DeleteNoteByIdParams) error {
	_, err := q.db.ExecContext(ctx, deleteNoteById, arg.ID, arg.UserID)
	return err
}

const getActiveCoinPacks = `-- name: GetActiveCoinPacks :many
SELECT id, coin_value, coin_price, popular
FROM coin_packs
WHERE active = TRUE
ORDER BY popular DESC, coin_value ASC
`

type GetActiveCoinPacksRow struct {
	ID        uuid.UUID    `json:"id"`
	CoinValue int32        `json:"coin_value"`
	CoinPrice int32        `json:"coin_price"`
	Popular   sql.NullBool `json:"popular"`
}

func (q *Queries) GetActiveCoinPacks(ctx context.Context) ([]GetActiveCoinPacksRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveCoinPacks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveCoinPacksRow
	for rows.Next() {
		var i GetActiveCoinPacksRow
		if err := rows.Scan(
			&i.ID,
			&i.CoinValue,
			&i.CoinPrice,
			&i.Popular,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsersNotes = `-- name: GetAllUsersNotes :many
SELECT id, user_id, audio_url, audio_duration_seconds, audio_file_size_mb, transcript, title, word_count, status, search_vector, created_at, updated_at
FROM notes
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetAllUsersNotes(ctx context.Context, userID uuid.UUID) ([]Note, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsersNotes, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AudioUrl,
			&i.AudioDurationSeconds,
			&i.AudioFileSizeMb,
			&i.Transcript,
			&i.Title,
			&i.WordCount,
			&i.Status,
			&i.SearchVector,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoinPackById = `-- name: GetCoinPackById :one
SELECT id, coin_value, coin_price, popular, active, created_at, updated_at
FROM coin_packs
WHERE id = $1
  AND active = TRUE
`

func (q *Queries) GetCoinPackById(ctx context.Context, id uuid.UUID) (CoinPack, error) {
	row := q.db.QueryRowContext(ctx, getCoinPackById, id)
	var i CoinPack
	err := row.Scan(
		&i.ID,
		&i.CoinValue,
		&i.CoinPrice,
		&i.Popular,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNoteByNoteId = `-- name: GetNoteByNoteId :one
SELECT id, user_id, audio_url, audio_duration_seconds, audio_file_size_mb, transcript, title, word_count, status, search_vector, created_at, updated_at
FROM notes
WHERE id = $1
    AND user_id = $2
`

type GetNoteByNoteIdParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) GetNoteByNoteId(ctx context.Context, arg GetNoteByNoteIdParams) (Note, error) {
	row := q.db.QueryRowContext(ctx, getNoteByNoteId, arg.ID, arg.UserID)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AudioUrl,
		&i.AudioDurationSeconds,
		&i.AudioFileSizeMb,
		&i.Transcript,
		&i.Title,
		&i.WordCount,
		&i.Status,
		&i.SearchVector,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id,email,google_id,picture,is_active,plan,user_device,created_at
FROM users
WHERE email = $1
`

type GetUserByEmailRow struct {
	ID         uuid.UUID      `json:"id"`
	Email      string         `json:"email"`
	GoogleID   sql.NullString `json:"google_id"`
	Picture    sql.NullString `json:"picture"`
	IsActive   bool           `json:"is_active"`
	Plan       string         `json:"plan"`
	UserDevice sql.NullString `json:"user_device"`
	CreatedAt  time.Time      `json:"created_at"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.GoogleID,
		&i.Picture,
		&i.IsActive,
		&i.Plan,
		&i.UserDevice,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmailLogin = `-- name: GetUserByEmailLogin :one
SELECT id, email, password, google_id, user_device, picture, is_active, plan, created_at, updated_at
FROM users
WHERE email = $1
`

func (q *Queries) GetUserByEmailLogin(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmailLogin, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.GoogleID,
		&i.UserDevice,
		&i.Picture,
		&i.IsActive,
		&i.Plan,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id,email,google_id,picture,is_active,plan,user_device,created_at
FROM users
WHERE id = $1
`

type GetUserByIdRow struct {
	ID         uuid.UUID      `json:"id"`
	Email      string         `json:"email"`
	GoogleID   sql.NullString `json:"google_id"`
	Picture    sql.NullString `json:"picture"`
	IsActive   bool           `json:"is_active"`
	Plan       string         `json:"plan"`
	UserDevice sql.NullString `json:"user_device"`
	CreatedAt  time.Time      `json:"created_at"`
}

func (q *Queries) GetUserById(ctx context.Context, id uuid.UUID) (GetUserByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getUserById, id)
	var i GetUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.GoogleID,
		&i.Picture,
		&i.IsActive,
		&i.Plan,
		&i.UserDevice,
		&i.CreatedAt,
	)
	return i, err
}

const getUserCoinBalance = `-- name: GetUserCoinBalance :one
SELECT balance
FROM user_coin
WHERE user_id = $1
`

func (q *Queries) GetUserCoinBalance(ctx context.Context, userID uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, getUserCoinBalance, userID)
	var balance int32
	err := row.Scan(&balance)
	return balance, err
}

const getUserCoinTransactions = `-- name: GetUserCoinTransactions :many
SELECT
    id,
    user_id,
    amount,
    reason,
    created_at,
    updated_at
FROM coin_transactions
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetUserCoinTransactions(ctx context.Context, userID uuid.UUID) ([]CoinTransaction, error) {
	rows, err := q.db.QueryContext(ctx, getUserCoinTransactions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoinTransaction
	for rows.Next() {
		var i CoinTransaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Amount,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCoins = `-- name: GetUserCoins :one
SELECT user_id, balance, updated_at
FROM user_coin
WHERE user_id = $1
`

func (q *Queries) GetUserCoins(ctx context.Context, userID uuid.UUID) (UserCoin, error) {
	row := q.db.QueryRowContext(ctx, getUserCoins, userID)
	var i UserCoin
	err := row.Scan(&i.UserID, &i.Balance, &i.UpdatedAt)
	return i, err
}

const googleAuth = `-- name: GoogleAuth :one
INSERT INTO users (email, google_id,picture,user_device)
VALUES ($1, $2,$3, $4)
ON CONFLICT (email)
DO UPDATE SET
    google_id = COALESCE(users.google_id, EXCLUDED.google_id),
    updated_at = now()
RETURNING id, email,plan,user_device,created_at
`

type GoogleAuthParams struct {
	Email      string         `json:"email"`
	GoogleID   sql.NullString `json:"google_id"`
	Picture    sql.NullString `json:"picture"`
	UserDevice sql.NullString `json:"user_device"`
}

type GoogleAuthRow struct {
	ID         uuid.UUID      `json:"id"`
	Email      string         `json:"email"`
	Plan       string         `json:"plan"`
	UserDevice sql.NullString `json:"user_device"`
	CreatedAt  time.Time      `json:"created_at"`
}

func (q *Queries) GoogleAuth(ctx context.Context, arg GoogleAuthParams) (GoogleAuthRow, error) {
	row := q.db.QueryRowContext(ctx, googleAuth,
		arg.Email,
		arg.GoogleID,
		arg.Picture,
		arg.UserDevice,
	)
	var i GoogleAuthRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Plan,
		&i.UserDevice,
		&i.CreatedAt,
	)
	return i, err
}

const searchNotes = `-- name: SearchNotes :many
SELECT id, user_id, audio_url, audio_duration_seconds, audio_file_size_mb, transcript, title, word_count, status, search_vector, created_at, updated_at
FROM notes
WHERE search_vector @@ plainto_tsquery('english',$1)
ORDER BY ts_rank(search_vector,plainto_tsquery('english',$1)) DESC
`

func (q *Queries) SearchNotes(ctx context.Context, plaintoTsquery string) ([]Note, error) {
	rows, err := q.db.QueryContext(ctx, searchNotes, plaintoTsquery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AudioUrl,
			&i.AudioDurationSeconds,
			&i.AudioFileSizeMb,
			&i.Transcript,
			&i.Title,
			&i.WordCount,
			&i.Status,
			&i.SearchVector,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const signup = `-- name: Signup :one
INSERT INTO users (email, password,user_device)
VALUES ($1, $2 , $3)
RETURNING id, email, plan, user_device,created_at
`

type SignupParams struct {
	Email      string         `json:"email"`
	Password   sql.NullString `json:"password"`
	UserDevice sql.NullString `json:"user_device"`
}

type SignupRow struct {
	ID         uuid.UUID      `json:"id"`
	Email      string         `json:"email"`
	Plan       string         `json:"plan"`
	UserDevice sql.NullString `json:"user_device"`
	CreatedAt  time.Time      `json:"created_at"`
}

func (q *Queries) Signup(ctx context.Context, arg SignupParams) (SignupRow, error) {
	row := q.db.QueryRowContext(ctx, signup, arg.Email, arg.Password, arg.UserDevice)
	var i SignupRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Plan,
		&i.UserDevice,
		&i.CreatedAt,
	)
	return i, err
}

const updateNoteWithNoteId = `-- name: UpdateNoteWithNoteId :one
UPDATE notes
SET
    title = $1,
    transcript = $2,
    updated_at = NOW()
WHERE id = $3
RETURNING id, user_id, audio_url, audio_duration_seconds, audio_file_size_mb, transcript, title, word_count, status, search_vector, created_at, updated_at
`

type UpdateNoteWithNoteIdParams struct {
	Title      sql.NullString `json:"title"`
	Transcript sql.NullString `json:"transcript"`
	ID         uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateNoteWithNoteId(ctx context.Context, arg UpdateNoteWithNoteIdParams) (Note, error) {
	row := q.db.QueryRowContext(ctx, updateNoteWithNoteId, arg.Title, arg.Transcript, arg.ID)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AudioUrl,
		&i.AudioDurationSeconds,
		&i.AudioFileSizeMb,
		&i.Transcript,
		&i.Title,
		&i.WordCount,
		&i.Status,
		&i.SearchVector,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
